---
title: 力扣24:两两交换链表中的节点
published: 2025-11-1
description: 力扣24:两两交换链表中的节点
image: "./cover.jpg"
tags: ["链表"]
category: 力扣
draft: false
---

### 题目

 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

### 思路

1.迭代，使用哨兵，同时不断向右迭代即可

2.递归，边界，节点数不足两个。在每个问题中使用三个节点，node1,node2,node3.

node3为子问题交换后的头节点，使node1指向node3,node2指向node1,即可完成两节点交换，不断递归即可

### 题解

1.迭代

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
    Dummy := &ListNode{}
    Dummy.Next = head
    cur := Dummy
    for  cur.Next != nil && cur.Next.Next != nil{
           Node1 := cur.Next
           Node2 := cur.Next.Next
           Node1.Next = Node1.Next.Next
           cur.Next = Node2
           Node2.Next = Node1
           cur = Node1
    }
    return Dummy.Next
}
```



2.递归

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func swapPairs(head *ListNode) *ListNode {
   if head == nil || head.Next == nil{
    return head
   }
   
   node1 := head
   node2 := head.Next
   node3 := head.Next.Next

   node1.Next = swapPairs(node3)
   node2.Next = node1
   return node2
}
```



